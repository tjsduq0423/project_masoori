{"ast":null,"code":"import { FLOAT32_EPSILON } from '../Constants.js';\nimport { makeEmptyBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { getTriCount } from './geometryUtils.js';\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nexport function getBounds(triangleBounds, offset, count, target, centroidTarget = null) {\n  let minx = Infinity;\n  let miny = Infinity;\n  let minz = Infinity;\n  let maxx = -Infinity;\n  let maxy = -Infinity;\n  let maxz = -Infinity;\n  let cminx = Infinity;\n  let cminy = Infinity;\n  let cminz = Infinity;\n  let cmaxx = -Infinity;\n  let cmaxy = -Infinity;\n  let cmaxz = -Infinity;\n  const includeCentroid = centroidTarget !== null;\n  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    const cx = triangleBounds[i + 0];\n    const hx = triangleBounds[i + 1];\n    const lx = cx - hx;\n    const rx = cx + hx;\n    if (lx < minx) minx = lx;\n    if (rx > maxx) maxx = rx;\n    if (includeCentroid && cx < cminx) cminx = cx;\n    if (includeCentroid && cx > cmaxx) cmaxx = cx;\n    const cy = triangleBounds[i + 2];\n    const hy = triangleBounds[i + 3];\n    const ly = cy - hy;\n    const ry = cy + hy;\n    if (ly < miny) miny = ly;\n    if (ry > maxy) maxy = ry;\n    if (includeCentroid && cy < cminy) cminy = cy;\n    if (includeCentroid && cy > cmaxy) cmaxy = cy;\n    const cz = triangleBounds[i + 4];\n    const hz = triangleBounds[i + 5];\n    const lz = cz - hz;\n    const rz = cz + hz;\n    if (lz < minz) minz = lz;\n    if (rz > maxz) maxz = rz;\n    if (includeCentroid && cz < cminz) cminz = cz;\n    if (includeCentroid && cz > cmaxz) cmaxz = cz;\n  }\n  target[0] = minx;\n  target[1] = miny;\n  target[2] = minz;\n  target[3] = maxx;\n  target[4] = maxy;\n  target[5] = maxz;\n  if (includeCentroid) {\n    centroidTarget[0] = cminx;\n    centroidTarget[1] = cminy;\n    centroidTarget[2] = cminz;\n    centroidTarget[3] = cmaxx;\n    centroidTarget[4] = cmaxy;\n    centroidTarget[5] = cmaxz;\n  }\n}\n\n// A stand alone function for retrieving the centroid bounds.\nexport function getCentroidBounds(triangleBounds, offset, count, centroidTarget) {\n  let cminx = Infinity;\n  let cminy = Infinity;\n  let cminz = Infinity;\n  let cmaxx = -Infinity;\n  let cmaxy = -Infinity;\n  let cmaxz = -Infinity;\n  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    const cx = triangleBounds[i + 0];\n    if (cx < cminx) cminx = cx;\n    if (cx > cmaxx) cmaxx = cx;\n    const cy = triangleBounds[i + 2];\n    if (cy < cminy) cminy = cy;\n    if (cy > cmaxy) cmaxy = cy;\n    const cz = triangleBounds[i + 4];\n    if (cz < cminz) cminz = cz;\n    if (cz > cmaxz) cmaxz = cz;\n  }\n  centroidTarget[0] = cminx;\n  centroidTarget[1] = cminy;\n  centroidTarget[2] = cminz;\n  centroidTarget[3] = cmaxx;\n  centroidTarget[4] = cmaxy;\n  centroidTarget[5] = cmaxz;\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nexport function computeTriangleBounds(geo, fullBounds) {\n  // clear the bounds to empty\n  makeEmptyBounds(fullBounds);\n  const posAttr = geo.attributes.position;\n  const index = geo.index ? geo.index.array : null;\n  const triCount = getTriCount(geo);\n  const triangleBounds = new Float32Array(triCount * 6);\n  const normalized = posAttr.normalized;\n\n  // used for non-normalized positions\n  const posArr = posAttr.array;\n\n  // support for an interleaved position buffer\n  const bufferOffset = posAttr.offset || 0;\n  let stride = 3;\n  if (posAttr.isInterleavedBufferAttribute) {\n    stride = posAttr.data.stride;\n  }\n\n  // used for normalized positions\n  const getters = ['getX', 'getY', 'getZ'];\n  for (let tri = 0; tri < triCount; tri++) {\n    const tri3 = tri * 3;\n    const tri6 = tri * 6;\n    let ai = tri3 + 0;\n    let bi = tri3 + 1;\n    let ci = tri3 + 2;\n    if (index) {\n      ai = index[ai];\n      bi = index[bi];\n      ci = index[ci];\n    }\n\n    // we add the stride and offset here since we access the array directly\n    // below for the sake of performance\n    if (!normalized) {\n      ai = ai * stride + bufferOffset;\n      bi = bi * stride + bufferOffset;\n      ci = ci * stride + bufferOffset;\n    }\n    for (let el = 0; el < 3; el++) {\n      let a, b, c;\n      if (normalized) {\n        a = posAttr[getters[el]](ai);\n        b = posAttr[getters[el]](bi);\n        c = posAttr[getters[el]](ci);\n      } else {\n        a = posArr[ai + el];\n        b = posArr[bi + el];\n        c = posArr[ci + el];\n      }\n      let min = a;\n      if (b < min) min = b;\n      if (c < min) min = c;\n      let max = a;\n      if (b > max) max = b;\n      if (c > max) max = c;\n\n      // Increase the bounds size by float32 epsilon to avoid precision errors when\n      // converting to 32 bit float. Scale the epsilon by the size of the numbers being\n      // worked with.\n      const halfExtents = (max - min) / 2;\n      const el2 = el * 2;\n      triangleBounds[tri6 + el2 + 0] = min + halfExtents;\n      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;\n      if (min < fullBounds[el]) fullBounds[el] = min;\n      if (max > fullBounds[el + 3]) fullBounds[el + 3] = max;\n    }\n  }\n  return triangleBounds;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}